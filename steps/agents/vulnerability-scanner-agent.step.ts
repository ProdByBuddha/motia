/**
 * Vulnerability Scanner Agent
 *
 * Scans for CVEs, misconfigurations, and security weaknesses.
 * Uses qwen3-coder:480b for code/config analysis.
 */

import { z } from 'zod';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export const config = {
  type: 'api',
  name: 'VulnerabilityScannerAgent',
  description: 'CVE and vulnerability scanning using qwen3-coder:480b',
  flows: ['vps-orchestration', 'security'],
  method: 'POST',
  path: '/api/agents/vulnerability-scanner/execute',
  emits: [],

  bodySchema: z.object({
    scan_target: z.enum(['packages', 'containers', 'ports', 'all']).default('all'),
    severity_filter: z.enum(['critical', 'high', 'medium', 'low', 'all']).default('high'),
  }),

  responseSchema: {
    200: z.object({
      vulnerabilities: z.array(z.object({
        cve_id: z.string().optional(),
        severity: z.string(),
        affected_component: z.string(),
        current_version: z.string().optional(),
        fixed_version: z.string().optional(),
        cvss_score: z.number().optional(),
        description: z.string(),
        remediation: z.string(),
      })),
      summary: z.object({
        total_vulnerabilities: z.number(),
        critical: z.number(),
        high: z.number(),
        medium: z.number(),
        low: z.number(),
      }),
      risk_score: z.number().min(0).max(100),
      recommendations: z.array(z.string()),
      metadata: z.object({
        duration_ms: z.number(),
        model_used: z.string(),
      }),
    }),
    500: z.object({ error: z.string() }),
  },
};

export const handler = async (req: any, { logger }: any) => {
  const { scan_target, severity_filter } = req.body;

  logger.info('Vulnerability scanner starting', { scan_target });

  const startTime = Date.now();

  try {
    // Scan packages
    const packages = await execAsync('dpkg -l 2>/dev/null | head -50 || rpm -qa 2>/dev/null | head -50 || echo "No package manager"');

    // Scan Docker images
    const dockerImages = await execAsync('docker images --format "{{.Repository}}:{{.Tag}}" 2>/dev/null | head -20 || echo "No docker"');

    // Check open ports
    const openPorts = await execAsync('netstat -tuln 2>/dev/null | grep LISTEN || ss -tuln 2>/dev/null | grep LISTEN || echo "No netstat"');

    // Check SSL certificates
    const sslCheck = await execAsync('find /etc -name "*.crt" -o -name "*.pem" 2>/dev/null | head -10 || echo "No certs found"');

    const prompt = `Perform vulnerability scan on this VPS:

=== INSTALLED PACKAGES ===
${packages.stdout.substring(0, 2000)}

=== DOCKER IMAGES ===
${dockerImages.stdout.substring(0, 1000)}

=== OPEN PORTS ===
${openPorts.stdout.substring(0, 1000)}

=== SSL CERTIFICATES ===
${sslCheck.stdout.substring(0, 500)}

Identify:
1. Known CVEs in packages/containers
2. Misconfigured services
3. Exposed ports that shouldn't be public
4. Expired or weak SSL certificates
5. Security configuration issues

For each vulnerability:
- Severity (critical/high/medium/low)
- Affected component
- CVE ID if known
- CVSS score if applicable
- Remediation steps

Also calculate overall risk score (0-100, higher = more risk)`;

    const ollamaApiKey = process.env.OLLAMA_API_KEY ||
                         'c6a38684cc3a4053a76ec07b92e94c46.N0tfbn0tVt9FRkBJWJWPjn-g';

    const ollamaResponse = await fetch('https://ollama.com/api/generate', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${ollamaApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'qwen3-coder:480b',
        prompt,
        system: 'You are a security vulnerability analyst. Identify CVEs and security weaknesses accurately.',
        stream: false,
        options: { temperature: 0.3 },
      }),
    });

    if (!ollamaResponse.ok) {
      throw new Error('Vulnerability scan failed');
    }

    const ollamaResult = await ollamaResponse.json();
    const responseText = ollamaResult.response || '';

    // Parse vulnerabilities
    const vulnerabilities: any[] = [];
    const vulnPattern = /(?:CVE-\d{4}-\d+|vulnerability):?\s*([^\n]+)/gi;
    let vulnMatch;

    while ((vulnMatch = vulnPattern.exec(responseText)) !== null) {
      const description = vulnMatch[1].trim();
      const severityMatch = description.match(/(critical|high|medium|low)/i);
      const severity = severityMatch ? severityMatch[1].toLowerCase() : 'medium';

      const cveMatch = vulnMatch[0].match(/CVE-\d{4}-\d+/);

      vulnerabilities.push({
        cve_id: cveMatch ? cveMatch[0] : undefined,
        severity,
        affected_component: 'System',  // Would extract from description
        description: description.substring(0, 200),
        remediation: 'Update affected package or apply security patch',
        cvss_score: severity === 'critical' ? 9.5 : severity === 'high' ? 7.5 : 5.0,
      });
    }

    // Calculate risk score
    const riskScore = Math.min(100,
      vulnerabilities.filter(v => v.severity === 'critical').length * 25 +
      vulnerabilities.filter(v => v.severity === 'high').length * 10 +
      vulnerabilities.filter(v => v.severity === 'medium').length * 3
    );

    // Extract recommendations
    const recommendations: string[] = [];
    const recMatches = responseText.matchAll(/(?:recommend|should|must):?\s*([^\n]+)/gi);
    for (const match of recMatches) {
      recommendations.push(match[1].trim());
    }

    const duration = Date.now() - startTime;

    const result = {
      vulnerabilities: vulnerabilities.slice(0, 50),
      summary: {
        total_vulnerabilities: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'critical').length,
        high: vulnerabilities.filter(v => v.severity === 'high').length,
        medium: vulnerabilities.filter(v => v.severity === 'medium').length,
        low: vulnerabilities.filter(v => v.severity === 'low').length,
      },
      risk_score: riskScore,
      recommendations: recommendations.slice(0, 10),
      metadata: {
        duration_ms: duration,
        model_used: 'qwen3-coder:480b',
      },
    };

    logger.info('Vulnerability scan completed', {
      vulnerabilitiesFound: vulnerabilities.length,
      riskScore,
      duration,
    });

    return {
      status: 200,
      body: result,
    };

  } catch (error: any) {
    logger.error('Vulnerability scanner failed', { error: error.message });

    return {
      status: 500,
      body: { error: 'Vulnerability scan failed' },
    };
  }
};
