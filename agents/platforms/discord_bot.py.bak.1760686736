"""
Discord Bot Integration for Agent Coordinator

Adds conversational chat, task management, self-dev approvals via buttons,
and a persistent jobs dashboard channel per server.
"""

import asyncio
import json
import os
import sys
from datetime import datetime
from typing import Optional

import discord
from discord.ext import commands, tasks
from discord import ui

# Make shared modules importable
sys.path.insert(0, "/opt/motia/agents/shared")
sys.path.insert(0, "/opt/motia/agents/platforms")

from agent_coordinator import AgentCoordinator, AgentRole, ActionType


class DiscordAgentBot(commands.Bot):
	"""Discord bot for agent coordination"""

	def __init__(self, coordinator: AgentCoordinator):
		intents = discord.Intents.default()
		intents.message_content = True
		intents.reactions = True

		super().__init__(command_prefix="!agent ", intents=intents)

		self.coordinator = coordinator
		self.coordinator.register_channel("discord", self)

		# Track message -> task mapping for reactions
		self.approval_messages: dict[int, str] = {}  # message_id -> task_id

		# Jobs dashboard (per guild) config cached in-memory
		self.jobs_dashboard_cache: dict[int, dict] = {}

		# Health dashboard (per guild)
		self.health_dashboard_cache: dict[int, dict] = {}

		# Setup commands
		self.setup_commands()

	def setup_commands(self):
		"""Setup bot commands"""

		@self.command(name="session")
		async def session_cmd(ctx, action: str = None, *args):
			"""
			Manage sessions (threads):
			!agent session new <name>
			!agent session list
			!agent session use <name_or_id>
			!agent session rename <old> <new>
			!agent session close <name_or_id>
			"""
			uid = str(ctx.author.id)
			if not action:
				return await ctx.send("Usage: !agent session [new|list|use|rename|close] ...")

			try:
				if action == "new" and args:
					name = " ".join(args).strip()
					sess = self.coordinator.create_session("discord", uid, name)
					return await ctx.send(f"âœ… Created session `{sess['name']}` (id={sess['id']}) and set active")
				if action == "list":
					rows = self.coordinator.list_sessions("discord", uid)
					if not rows:
						return await ctx.send("No sessions. Create one with `!agent session new <name>`.")
					lines = []
					for r in rows:
						star = "â­" if r["active"] else " "
						lines.append(f"{star} {r['name']} ({r['id']}) - {r['messages']} msgs, {r['created_at']}")
					return await ctx.send("Sessions:\n" + "\n".join(lines))
				if action == "use" and args:
					sel = " ".join(args).strip()
					sess = self.coordinator.use_session("discord", uid, sel)
					return await ctx.send(f"âœ… Switched to session `{sess['name']}`")
				if action == "rename" and len(args) >= 2:
					old = args[0].strip()
					new = " ".join(args[1:]).strip()
					sess = self.coordinator.rename_session("discord", uid, old, new)
					return await ctx.send(f"âœ… Renamed session to `{sess['name']}`")
				if action == "close" and args:
					sel = " ".join(args).strip()
					sid = self.coordinator.close_session("discord", uid, sel)
					return await ctx.send(f"ğŸ—‘ï¸ Closed session {sid}")
				return await ctx.send("Usage: !agent session [new|list|use|rename|close] ...")
			except Exception as e:
				return await ctx.send(f"âŒ {e}")

		@self.command(name="task")
		async def create_task(ctx, role: str, action: str, *, description: str):
			"""Create a new task: !agent task <role> <action> <description>"""
			try:
				agent_role = AgentRole(role)
				action_type = ActionType(action)
				task = await self.coordinator.create_task(
					title=f"Task from {ctx.author.name}",
					description=description,
					assigned_to=agent_role,
					action_type=action_type,
					created_by=f"discord:{ctx.author.id}",
				)
				embed = discord.Embed(title="âœ… Task Created", description=f"**Task ID**: `{task.task_id}`\n**Status**: {task.status}", color=discord.Color.green())
				embed.add_field(name="Role", value=task.assigned_to.value, inline=True)
				embed.add_field(name="Action Type", value=task.action_type.value, inline=True)
				if task.requires_approval:
					embed.add_field(name="âš ï¸ Status", value="Pending approval", inline=False)
				await ctx.send(embed=embed)
			except Exception as e:
				await ctx.send(f"âŒ Error creating task: {e}")

		@self.command(name="approve")
		async def approve_task(ctx, task_id: str):
			try:
				await self.coordinator.approve_task(task_id, f"discord:{ctx.author.id}")
				await ctx.send(f"âœ… Task `{task_id}` approved and executing")
			except Exception as e:
				await ctx.send(f"âŒ Error approving task: {e}")

		@self.command(name="status")
		async def task_status(ctx, task_id: str):
			try:
				status = await self.coordinator.get_task_status(task_id)
				embed = discord.Embed(title=f"ğŸ“Š Task Status: {status['title']}", description=f"**ID**: `{status['task_id']}`", color=discord.Color.blue())
				embed.add_field(name="Status", value=status["status"], inline=True)
				embed.add_field(name="Assigned To", value=status["assigned_to"], inline=True)
				embed.add_field(name="Action Type", value=status["action_type"], inline=True)
				embed.add_field(name="Description", value=status["description"], inline=False)
				if status.get("result"):
					result_str = json.dumps(status["result"], indent=2)
					if len(result_str) > 1000:
						result_str = result_str[:1000] + "... (truncated)"
					embed.add_field(name="Result", value=f"```json\n{result_str}\n```", inline=False)
				await ctx.send(embed=embed)
			except Exception as e:
				await ctx.send(f"âŒ Error getting status: {e}")

		@self.command(name="pending")
		async def pending_approvals(ctx):
			pending = await self.coordinator.get_pending_approvals()
			if not pending:
				await ctx.send("âœ… No pending approvals")
				return
			embed = discord.Embed(title="â³ Pending Approvals", description=f"{len(pending)} tasks awaiting approval", color=discord.Color.orange())
			for task in pending[:10]:
				embed.add_field(name=f"{task.task_id}", value=(f"**{task.title}**\n{task.description[:100]}...\n" f"*{task.assigned_to.value} | {task.action_type.value}*"), inline=False)
			await ctx.send(embed=embed)

		@self.command(name="build")
		async def build_app(ctx, *, description: str):
			task = await self.coordinator.create_task(
				title=f"Build: {description[:50]}",
				description=f"Design and implement: {description}",
				assigned_to=AgentRole.ARCHITECT,
				action_type=ActionType.SAFE,
				created_by=f"discord:{ctx.author.id}",
			)
			embed = discord.Embed(title="ğŸ—ï¸ Building Application", description="Agents are working on your project...", color=discord.Color.blue())
			embed.add_field(name="Task ID", value=f"`{task.task_id}`", inline=True)
			embed.add_field(name="Status", value="In Progress", inline=True)
			embed.add_field(name="Process", value=("1. Architect designs system\n" "2. Agents implement components\n" "3. QA tests\n" "4. DevOps deploys"), inline=False)
			await ctx.send(embed=embed)

		@self.command(name="talk")
		async def talk_to_agent(ctx, role: str, *, message: str):
			try:
				agent_role = AgentRole(role)
				agent = self.coordinator.agents.get(agent_role)
				if not agent:
					await ctx.send(f"âŒ Agent not found: {role}")
					return
				agent.set_mode("conversational")
				response = await agent.run_conversational(message)
				embed = discord.Embed(title=f"ğŸ’¬ {agent_role.value.replace('_', ' ').title()}", description=response, color=discord.Color.purple())
				await ctx.send(embed=embed)
			except Exception as e:
				await ctx.send(f"âŒ Error: {e}")

		@self.command(name="agents")
		async def list_agents(ctx):
			embed = discord.Embed(title="ğŸ¤– Available Agents", description="Your autonomous dev team", color=discord.Color.green())
			for role in AgentRole:
				embed.add_field(name=role.value.replace("_", " ").title(), value=f"Role: `{role.value}`", inline=True)
			await ctx.send(embed=embed)

		@self.command(name="help_agent")
		async def help_command(ctx):
			embed = discord.Embed(title="ğŸ¤– Agent System Help", description="Autonomous dev agency at your command", color=discord.Color.blue())
			embed.add_field(name="!agent build <description>", value="Have agents build an application", inline=False)
			embed.add_field(name="!agent task <role> <action> <description>", value=("Create a specific task\n" "Roles: architect, backend_dev, frontend_dev, devops, qa, security, tech_writer\n" "Actions: safe, moderate, destructive"), inline=False)
			embed.add_field(name="!agent approve <task_id>", value="Approve a pending task", inline=False)
			embed.add_field(name="!agent status <task_id>", value="Check task status", inline=False)
			embed.add_field(name="!agent pending", value="List tasks awaiting approval", inline=False)
			embed.add_field(name="!agent talk <role> <message>", value="Chat with a specific agent", inline=False)
			embed.add_field(name="!agent agents", value="List all available agents", inline=False)
			await ctx.send(embed=embed)

		@self.command(name="jobs")
		async def jobs_cmd(ctx, action: str = None, *args):
			guild = ctx.guild
			if not guild:
				return await ctx.send("âŒ This must be run in a server channel.")
			if not action:
				return await ctx.send("Usage: !agent jobs [setup|refresh] ...")
			try:
				if action == "setup":
					if not args:
						return await ctx.send("Usage: !agent jobs setup here | channel <#channel> | create <name>")
					sub = args[0]
					if sub == "here":
						await self._set_jobs_dashboard(guild.id, ctx.channel.id)
						return await ctx.send("âœ… Jobs dashboard bound to this channel.")
					if sub == "channel" and len(args) >= 2:
						ch_mention = args[1]
						ch_id = None
						if ch_mention.startswith("<#") and ch_mention.endswith(">"):
							try:
								ch_id = int(ch_mention[2:-1])
							except Exception:
								pass
						if not ch_id:
							return await ctx.send("âŒ Please mention a channel like #dashboard")
						await self._set_jobs_dashboard(guild.id, ch_id)
						return await ctx.send(f"âœ… Jobs dashboard bound to <#{ch_id}>")
					if sub == "create" and len(args) >= 2:
						name = " ".join(args[1:])
						ch = await guild.create_text_channel(name)
						await self._set_jobs_dashboard(guild.id, ch.id)
						return await ctx.send(f"âœ… Created and bound dashboard channel {ch.mention}")
					return await ctx.send("âŒ Unknown setup subcommand")
				if action == "refresh":
					await self.refresh_jobs_dashboard(guild.id)
					return await ctx.send("ğŸ”„ Dashboard refreshed")
				return await ctx.send("âŒ Unknown jobs action")
			except discord.Forbidden:
				return await ctx.send("âŒ Missing permissions to manage channels or send messages")
			except Exception as e:
				return await ctx.send(f"âŒ {e}")

		@self.command(name="health")
		async def health_cmd(ctx, action: str = None, *args):
			"""
			Health dashboard management:
			- !agent health setup here | channel <#channel>
			- !agent health refresh
			"""
			guild = ctx.guild
			if not guild:
				return await ctx.send("âŒ This must be run in a server channel.")
			if not action:
				return await ctx.send("Usage: !agent health [setup|refresh] ...")
			try:
				if action == "setup":
					if not args:
						return await ctx.send("Usage: !agent health setup here | channel <#channel>")
					sub = args[0]
					if sub == "here":
						await self._set_health_dashboard(guild.id, ctx.channel.id)
						await self.refresh_health_dashboard(guild.id)
						return await ctx.send("âœ… Health dashboard bound to this channel.")
					if sub == "channel" and len(args) >= 2:
						ch_mention = args[1]
						ch_id = None
						if ch_mention.startswith("<#") and ch_mention.endswith(">"):
							try: ch_id = int(ch_mention[2:-1])
							except Exception: pass
						if not ch_id:
							return await ctx.send("âŒ Please mention a channel like #health")
						await self._set_health_dashboard(guild.id, ch_id)
						await self.refresh_health_dashboard(guild.id)
						return await ctx.send(f"âœ… Health dashboard bound to <#{ch_id}>")
					return await ctx.send("âŒ Unknown setup subcommand")
				if action == "refresh":
					await self.refresh_health_dashboard(guild.id)
					return await ctx.send("ğŸ”„ Health dashboard refreshed")
			except discord.Forbidden:
				return await ctx.send("âŒ Missing permissions to manage channels or send messages")
			except Exception as e:
				return await ctx.send(f"âŒ {e}")

	async def on_message(self, message):
		if message.author.bot:
			return
		await self.process_commands(message)
		is_dm = isinstance(message.channel, discord.DMChannel)
		is_mention = self.user in message.mentions
		if not (is_dm or is_mention):
			return
		text = message.content
		if is_mention:
			mention1 = f"<@{self.user.id}>"
			mention2 = f"<@!{self.user.id}>"
			text = text.replace(mention1, "").replace(mention2, "").strip()
		if not text:
			return
		try:
			reply = await self.coordinator.handle_natural_message(platform="discord", user_id=str(message.author.id), text=text)
			if isinstance(rely := reply, dict):
				text_out = rely.get("text") or ""
				if text_out:
					await message.channel.send(text_out)
				for notif in rely.get("notifications") or []:
					await self.show_builder_notification(message.channel, notif, requester=message.author)
			else:
				if reply:
					await message.channel.send(reply)
		except Exception as e:
			await message.channel.send(f"âŒ {e}")

	async def on_ready(self):
		"""Bot ready callback"""
		print(f"[DiscordBot] Logged in as {self.user}")
		print(f"[DiscordBot] Connected to {len(self.guilds)} servers")
		if not self.coordinator.lead_user_id:
			for guild in self.guilds:
				self.coordinator.set_lead_user(f"discord:{guild.owner_id}")
				break
		# register persistent views for current jobs
		try:
			await self._register_persistent_job_views()
		except Exception:
			pass
		# start dashboard refresh loop
		try:
			self._jobs_refresh_loop.start()
		except Exception:
			pass
		# start health refresh loop
		try:
			self._health_refresh_loop.start()
		except Exception:
			pass

	async def _register_persistent_job_views(self):
		import aiohttp
		builder_url = os.getenv("BUILDER_API_URL", "http://127.0.0.1:4010")
		jobs = []
		try:
			async with aiohttp.ClientSession() as s:
				async with s.get(builder_url + "/jobs/list?limit=25", timeout=15) as resp:
					data = await resp.json()
					jobs = data.get("jobs") or []
		except Exception:
			jobs = []
		for j in jobs:
			jid = j.get("id") or j.get("job_id")
			status = j.get("status")
			if not jid or status in ("applied","rejected"):
				continue
			# Register a view with persistent custom IDs
			view = ui.View(timeout=None)
			view.add_item(self._ApproveJobButton(self, jid))
			view.add_item(self._RejectJobButton(self, jid))
			view.add_item(self._DetailsJobButton(self, jid))
			self.add_view(view)

	async def on_reaction_add(self, reaction, user):
		"""Handle reaction-based approvals (legacy)."""
		if user.bot:
			return
		message_id = reaction.message.id
		if message_id not in self.approval_messages:
			return
		task_id = self.approval_messages[message_id]
		if str(reaction.emoji) == "âœ…":
			await self.coordinator.approve_task(task_id, f"discord:{user.id}")
			await reaction.message.channel.send(f"âœ… Task `{task_id}` approved by {user.mention}")
		elif str(reaction.emoji) == "âŒ":
			task = self.coordinator.tasks.get(task_id)
			if task:
				task.status = "rejected"
				await reaction.message.channel.send(f"âŒ Task `{task_id}` rejected by {user.mention}")

	async def send_message(self, user_id: str, message: str):
		"""Send a message to a user (for coordinator notifications)"""
		if user_id.startswith("discord:"):
			discord_id = int(user_id.split(":")[1])
			user = await self.fetch_user(discord_id)
			if user:
				await user.send(message)

	async def _set_jobs_dashboard(self, guild_id: int, channel_id: int):
		self.jobs_dashboard_cache.setdefault(guild_id, {})["channel_id"] = channel_id
		if self.coordinator.redis_client:
			key = f"jobs_dashboard:channel:{guild_id}"
			await self.coordinator.redis_client.set(key, str(channel_id))

	async def _get_jobs_dashboard_channel(self, guild_id: int) -> Optional[int]:
		c = self.jobs_dashboard_cache.get(guild_id, {}).get("channel_id")
		if c:
			return int(c)
		if self.coordinator.redis_client:
			key = f"jobs_dashboard:channel:{guild_id}"
			val = await self.coordinator.redis_client.get(key)
			if val:
				self.jobs_dashboard_cache.setdefault(guild_id, {})["channel_id"] = int(val)
				return int(val)
		return None

	async def _set_jobs_dashboard_message(self, guild_id: int, message_id: int):
		self.jobs_dashboard_cache.setdefault(guild_id, {})["message_id"] = message_id
		if self.coordinator.redis_client:
			key = f"jobs_dashboard:message:{guild_id}"
			await self.coordinator.redis_client.set(key, str(message_id))

	async def _get_jobs_dashboard_message(self, guild_id: int) -> Optional[int]:
		m = self.jobs_dashboard_cache.get(guild_id, {}).get("message_id")
		if m:
			return int(m)
		if self.coordinator.redis_client:
			key = f"jobs_dashboard:message:{guild_id}"
			val = await self.coordinator.redis_client.get(key)
			if val:
				self.jobs_dashboard_cache.setdefault(guild_id, {})["message_id"] = int(val)
				return int(val)
		return None

	@tasks.loop(seconds=120)
	async def _jobs_refresh_loop(self):
		try:
			for g in self.guilds:
				await self.refresh_jobs_dashboard(g.id)
		except Exception:
			pass

	async def refresh_jobs_dashboard(self, guild_id: int):
		ch_id = await self._get_jobs_dashboard_channel(guild_id)
		if not ch_id:
			return
		guild = self.get_guild(guild_id)
		if not guild:
			return
		channel = guild.get_channel(ch_id)
		if not channel:
			return
		# Fetch jobs list
		import aiohttp
		builder_url = os.getenv("BUILDER_API_URL", "http://127.0.0.1:4010")
		jobs = []
		try:
			async with aiohttp.ClientSession() as s:
				async with s.get(builder_url + "/jobs/list?limit=15", timeout=15) as resp:
					data = await resp.json()
					jobs = data.get("jobs") or []
		except Exception:
			jobs = []
		lines = []
		for j in jobs[:15]:
			jid = j.get("id") or j.get("job_id") or "?"
			status = j.get("status")
			kind = j.get("kind")
			desc = (j.get("payload") or {}).get("description") or (j.get("payload") or {}).get("topic") or ""
			lines.append(f"`{jid}` â€¢ {kind} â€¢ {status} â€” {desc[:60]}")
		desc = "\n".join(lines) if lines else "No jobs yet. Use propose_patch or scaffold_service to start."
		embed = discord.Embed(title="ğŸ—‚ï¸ Builder Jobs", description=desc, color=discord.Color.blurple())
		# Build dynamic buttons (top 5) with persistent custom_ids
		view = ui.View(timeout=None)
		for j in jobs[:5]:
			jid = j.get("id") or j.get("job_id")
			status = j.get("status")
			if not jid or status in ("applied", "rejected"):
				continue
			view.add_item(self._ApproveJobButton(self, jid))
			view.add_item(self._RejectJobButton(self, jid))
			view.add_item(self._DetailsJobButton(self, jid))
		# Upsert message
		msg_id = await self._get_jobs_dashboard_message(guild_id)
		if msg_id:
			try:
				msg = await channel.fetch_message(msg_id)
				await msg.edit(embed=embed, view=view)
				return
			except Exception:
				pass
		msg = await channel.send(embed=embed, view=view)
		await self._set_jobs_dashboard_message(guild_id, msg.id)

	@tasks.loop(seconds=120)
	async def _health_refresh_loop(self):
		try:
			for g in self.guilds:
				await self.refresh_health_dashboard(g.id)
		except Exception:
			pass

	async def _set_health_dashboard(self, guild_id: int, channel_id: int):
		self.health_dashboard_cache.setdefault(guild_id, {})["channel_id"] = channel_id
		if self.coordinator.redis_client:
			key = f"health_dashboard:channel:{guild_id}"
			await self.coordinator.redis_client.set(key, str(channel_id))

	async def _get_health_dashboard_channel(self, guild_id: int) -> Optional[int]:
		c = self.health_dashboard_cache.get(guild_id, {}).get("channel_id")
		if c:
			return int(c)
		if self.coordinator.redis_client:
			key = f"health_dashboard:channel:{guild_id}"
			val = await self.coordinator.redis_client.get(key)
			if val:
				self.health_dashboard_cache.setdefault(guild_id, {})["channel_id"] = int(val)
				return int(val)
		return None

	async def _set_health_dashboard_message(self, guild_id: int, message_id: int):
		self.health_dashboard_cache.setdefault(guild_id, {})["message_id"] = message_id
		if self.coordinator.redis_client:
			key = f"health_dashboard:message:{guild_id}"
			await self.coordinator.redis_client.set(key, str(message_id))

	async def _get_health_dashboard_message(self, guild_id: int) -> Optional[int]:
		m = self.health_dashboard_cache.get(guild_id, {}).get("message_id")
		if m:
			return int(m)
		if self.coordinator.redis_client:
			key = f"health_dashboard:message:{guild_id}"
			val = await self.coordinator.redis_client.get(key)
			if val:
				self.health_dashboard_cache.setdefault(guild_id, {})["message_id"] = int(val)
				return int(val)
		return None

	async def refresh_health_dashboard(self, guild_id: int):
		# import late to avoid issues
		try:
			from health_reporter import get_system_metrics, get_docker_summary
		except Exception:
			get_system_metrics = None; get_docker_summary = None
		ch_id = await self._get_health_dashboard_channel(guild_id)
		if not ch_id:
			return
		guild = self.get_guild(guild_id)
		if not guild:
			return
		channel = guild.get_channel(ch_id)
		if not channel:
			return
		# Collect metrics
		try:
			sysm = get_system_metrics() if get_system_metrics else {}
			dock = get_docker_summary() if get_docker_summary else {"containers": []}
		except Exception:
			sysm = {}; dock = {"containers": []}
		# Build embed
		load = sysm.get('loadavg', {})
		embed = discord.Embed(title="VPS Health", description=f"Updated: {sysm.get('timestamp','')}", color=discord.Color.blurple())
		embed.add_field(name="System", value=f"Uptime: {sysm.get('uptime_pretty','?')}\nLoad: {load.get('1m',0):.2f} {load.get('5m',0):.2f} {load.get('15m',0):.2f}", inline=True)
		mi = sysm.get('meminfo', {})
		embed.add_field(name="Memory", value=f"Total: {mi.get('MemTotal','?')}\nAvail: {mi.get('MemAvailable','?')}\nSwap: {mi.get('SwapFree','?')}/{mi.get('SwapTotal','?')}", inline=True)
		disks = sysm.get('disks', {})
		if disks:
			root = disks.get('/', {})
			val = f"/: {root.get('used_gb','?')}/{root.get('total_gb','?')} GB"
			if '/opt' in disks:
				d = disks['/opt']
				val += f"\n/opt: {d.get('used_gb','?')}/{d.get('total_gb','?')} GB"
			embed.add_field(name="Disk", value=val, inline=True)
		cons = dock.get('containers', [])
		running = [c for c in cons if str(c.get('status','')).lower().startswith('up')]
		# thresholds
		def _pct(s: str) -> float:
			try:
				return float(str(s).strip().replace('%',''))
			except Exception:
				return 0.0
		cpu_thr = 0.0
		mem_thr = 0.0
		try:
			cpu_thr = float(os.getenv('HEALTH_ALERT_CPU_PCT', '90'))
		except Exception:
			cpu_thr = 90.0
		try:
			mem_thr = float(os.getenv('HEALTH_ALERT_MEM_PCT', '90'))
		except Exception:
			mem_thr = 90.0
		flagged = []
		for c in cons:
			stats = c.get('stats', {})
			line = f"â€¢ {c['name']} â€” {c['status']}\n"
			if stats:
				line += f"  CPU {stats.get('cpu','?')} MEM {stats.get('mem_pct','?')} ({stats.get('mem_usage','?')})\n"
				cpu = _pct(stats.get('cpu','0'))
				mem = _pct(stats.get('mem_pct','0'))
				if cpu >= cpu_thr or mem >= mem_thr:
					flagged.append(c)
			else:
				# No stats present or not running
				if not str(c.get('status','')).lower().startswith('up'):
					flagged.append(c)
		# Build Docker value with limits
		max_lines = 8
		lines = [f"Running: {len(running)}/{len(cons)}"]
		for c in cons[:max_lines]:
			stats = c.get('stats', {})
			ln = f"â€¢ {c['name']} â€” {c['status']}\n"
			if stats:
				ln += f"  CPU {stats.get('cpu','?')} MEM {stats.get('mem_pct','?')} ({stats.get('mem_usage','?')})\n"
			lines.append(ln.rstrip())
		if len(cons) > max_lines:
			lines.append(f"â€¦ (+{len(cons)-max_lines} more)")
		val = "\n".join(lines)
		# Discord field value must be <= 1024 chars
		if len(val) > 1024:
			val = val[:1000] + "â€¦"
		embed.add_field(name="Docker", value=val or '-', inline=False)
		# View with refresh button
		view = ui.View(timeout=None)
		view.add_item(self._HealthRefreshButton(self))
		view.add_item(self._HealthViewAllButton(self))
		# Add restart buttons for flagged (max 5)
		for c in flagged[:5]:
			try:
				view.add_item(self._RestartContainerButton(self, c['name']))
			except Exception:
				pass
		msg_id = await self._get_health_dashboard_message(guild_id)
		if msg_id:
			try:
				msg = await channel.fetch_message(msg_id)
				await msg.edit(embed=embed, view=view)
				return
			except Exception:
				pass
		msg = await channel.send(embed=embed, view=view)
		await self._set_health_dashboard_message(guild_id, msg.id)

	class _HealthRefreshButton(ui.Button):
		def __init__(self, bot: 'DiscordAgentBot'):
			super().__init__(label="Refresh", style=discord.ButtonStyle.primary, emoji="ğŸ”„", custom_id=f"health:refresh")
			self.bot = bot
		async def callback(self, interaction: discord.Interaction):
			await interaction.response.defer(thinking=False)
			try:
				await self.bot.refresh_health_dashboard(interaction.guild_id)
				await interaction.followup.send("Refreshed.", ephemeral=True)
			except Exception as e:
				await interaction.followup.send(f"âŒ {e}", ephemeral=True)

	class _HealthViewAllButton(ui.Button):
		def __init__(self, bot: 'DiscordAgentBot'):
			super().__init__(label="View All", style=discord.ButtonStyle.secondary, emoji="ğŸ“„", custom_id=f"health:viewall")
			self.bot = bot
		async def callback(self, interaction: discord.Interaction):
			await interaction.response.defer(thinking=False)
			try:
				# Fetch fresh docker summary
				try:
					from health_reporter import get_docker_summary
				except Exception:
					get_docker_summary = None
				dock = get_docker_summary() if get_docker_summary else {"containers": []}
				cons = dock.get('containers', [])
				# Build full text
				lines = []
				for c in cons:
					ln = f"{c['name']} â€” {c['status']} ({c.get('image','')})"
					st = c.get('stats', {})
					if st:
						ln += f"\n  CPU {st.get('cpu','?')} MEM {st.get('mem_pct','?')} ({st.get('mem_usage','?')})"
					lines.append(ln)
				text = "\n".join(lines) or "(no containers)"
				# Chunk into 1900-char pieces with code blocks
				chunks = []
				cur = []
				length = 0
				for line in text.split('\n'):
					if length + len(line) + 1 > 1900:
						chunks.append("\n".join(cur)); cur=[]; length=0
					cur.append(line); length += len(line) + 1
				if cur: chunks.append("\n".join(cur))
				# Create or reuse a thread
				parent_msg = interaction.message
				thread = None
				try:
					thread = await parent_msg.create_thread(name="Containers")
				except Exception:
					try:
						thread = await interaction.channel.create_thread(name=f"Containers-{datetime.utcnow().strftime('%H%M%S')}")
					except Exception:
						thread = None
				if thread:
					for ch in chunks:
						await thread.send(f"```text\n{ch}\n```")
					await interaction.followup.send("Posted full container list in thread.", ephemeral=True)
				else:
					# Fallback: ephemeral, may need multiple chunks
					for ch in chunks[:3]:
						await interaction.followup.send(f"```text\n{ch}\n```", ephemeral=True)
			except Exception as e:
				await interaction.followup.send(f"âŒ View All failed: {e}", ephemeral=True)

	class _RestartContainerButton(ui.Button):
		def __init__(self, bot: 'DiscordAgentBot', name: str):
			super().__init__(label=f"Restart {name[:10]}", style=discord.ButtonStyle.danger, emoji="â™»ï¸", custom_id=f"health:restart:{name}")
			self.bot = bot
			self.name = name
		async def callback(self, interaction: discord.Interaction):
			await interaction.response.defer(thinking=False)
			try:
				proc = await asyncio.create_subprocess_exec('docker','restart', self.name, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.STDOUT)
				out,_ = await proc.communicate()
				await interaction.followup.send(f"Restarted `{self.name}` (rc={proc.returncode})\n```\n{(out or b'').decode()[:800]}\n```", ephemeral=True)
			except Exception as e:
				await interaction.followup.send(f"âŒ Restart failed for `{self.name}`: {e}", ephemeral=True)
			finally:
				await self.bot.refresh_health_dashboard(interaction.guild_id)

	class _ApproveJobButton(ui.Button):
		def __init__(self, bot: 'DiscordAgentBot', job_id: str):
			super().__init__(label=f"Approve {job_id[:6]}", style=discord.ButtonStyle.success, emoji="âœ…", custom_id=f"job:approve:{job_id}")
			self.bot = bot
			self.job_id = job_id
		async def callback(self, interaction: discord.Interaction):
			await interaction.response.defer(thinking=False)
			try:
				url = os.getenv("BUILDER_API_URL", "http://127.0.0.1:4010") + "/jobs/apply"
				payload = {"job_id": self.job_id, "force": True}
				import aiohttp
				async with aiohttp.ClientSession() as s:
					await s.post(url, json=payload, timeout=30)
				await interaction.followup.send(f"âœ… Applied `{self.job_id}`", ephemeral=True)
			except Exception as e:
				await interaction.followup.send(f"âŒ {e}", ephemeral=True)
			finally:
				await self.bot.refresh_jobs_dashboard(interaction.guild_id)

	class _RejectJobButton(ui.Button):
		def __init__(self, bot: 'DiscordAgentBot', job_id: str):
			super().__init__(label=f"Reject {job_id[:6]}", style=discord.ButtonStyle.danger, emoji="âŒ", custom_id=f"job:reject:{job_id}")
			self.bot = bot
			self.job_id = job_id
		async def callback(self, interaction: discord.Interaction):
			await interaction.response.defer(thinking=False)
			try:
				url = os.getenv("BUILDER_API_URL", "http://127.0.0.1:4010") + "/jobs/reject"
				payload = {"job_id": self.job_id, "reason": f"rejected by {interaction.user.id}"}
				import aiohttp
				async with aiohttp.ClientSession() as s:
					await s.post(url, json=payload, timeout=30)
				await interaction.followup.send(f"ğŸ›‘ Rejected `{self.job_id}`", ephemeral=True)
			except Exception as e:
				await interaction.followup.send(f"âŒ {e}", ephemeral=True)
			finally:
				await self.bot.refresh_jobs_dashboard(interaction.guild_id)

	class _DetailsJobButton(ui.Button):
		def __init__(self, bot: 'DiscordAgentBot', job_id: str):
			super().__init__(label=f"Details {job_id[:6]}", style=discord.ButtonStyle.secondary, emoji="ğŸ“„", custom_id=f"job:details:{job_id}")
			self.bot = bot
			self.job_id = job_id
		async def callback(self, interaction: discord.Interaction):
			await interaction.response.defer(thinking=False)
			try:
				# Fetch job details
				import aiohttp
				builder_url = os.getenv("BUILDER_API_URL", "http://127.0.0.1:4010")
				async with aiohttp.ClientSession() as s:
					async with s.get(builder_url + f"/jobs/{self.job_id}", timeout=20) as resp:
						job = await resp.json()
				# Open a thread and post full details
				parent_msg = interaction.message
				thread = None
				try:
					thread = await parent_msg.create_thread(name=f"Job {self.job_id}")
				except Exception:
					thread = None
				# Prefer RFC text if present
				rfc = (((job.get('result') or {}).get('rfc')) or ((job.get('payload') or {}).get('rfc'))) or ''
				if rfc and thread:
					for chunk in [rfc[i:i+1800] for i in range(0, len(rfc), 1800)]:
						await thread.send(f"```md\n{chunk}\n```")
					await interaction.followup.send(f"ğŸ“„ Opened RFC thread for `{self.job_id}`", ephemeral=True)
					return
				text = json.dumps({k: job.get(k) for k in ("id","kind","status","payload","result")}, indent=2)
				if thread:
					await thread.send(f"```json\n{text[:1900]}\n```")
					await interaction.followup.send(f"ğŸ“„ Opened thread for `{self.job_id}`", ephemeral=True)
				else:
					await interaction.followup.send(f"```json\n{text[:1900]}\n```", ephemeral=True)
			except Exception as e:
				await interaction.followup.send(f"âŒ Details failed: {e}", ephemeral=True)

	async def show_builder_notification(self, channel: discord.abc.Messageable, notif: dict, requester: Optional[discord.Member] = None):
		"""Show interactive approval embed for staged jobs from notifications."""
		try:
			ntype = notif.get("type")
			tool = notif.get("tool")
			job_id = notif.get("job_id")
			if ntype != "builder_job" or not job_id:
				return
			title = {
				"propose_patch": "ğŸ”§ Proposed Patch Staged",
				"scaffold_service": "ğŸ§± Service Scaffold Staged",
				"run_tests": "ğŸ§ª Test Run Result",
				"apply": "ğŸš€ Apply Result",
				"rfc": "ğŸ“ RFC Draft",
			}.get(tool, "ğŸ”” Builder Job")
			desc = f"Job `{job_id}` via `{tool}`"
			summary = notif.get("summary") or {}
			if summary:
				kv = [f"{k}: {v}" for k, v in summary.items()]
				desc += "\n" + ", ".join(kv)
			embed = discord.Embed(title=title, description=desc, color=discord.Color.orange())
			# Add richer preview for RFC/op list by fetching job
			try:
				import aiohttp
				builder_url = os.getenv("BUILDER_API_URL", "http://127.0.0.1:4010")
				async with aiohttp.ClientSession() as s:
					async with s.get(builder_url + f"/jobs/{job_id}", timeout=8) as resp:
						job = await resp.json()
				if tool == 'rfc':
					rfc = (((job.get('result') or {}).get('rfc')) or ((job.get('payload') or {}).get('rfc'))) or ''
					if rfc:
						preview = (rfc[:500] + 'â€¦') if len(rfc) > 500 else rfc
						embed.add_field(name="RFC (preview)", value=f"```md\n{preview}\n```\nUse Details for full RFC.", inline=False)
				elif tool == 'propose_patch':
					applied = ((job.get('result') or {}).get('applied')) or []
					if applied:
						lines = []
						for op in applied[:5]:
							lines.append(f"â€¢ {op.get('op')} {op.get('path')}")
						more = '' if len(applied) <= 5 else f"\n(+{len(applied)-5} more)"
						embed.add_field(name="Operations", value="\n".join(lines) + more, inline=False)
			except Exception:
				pass
			view = ui.View(timeout=None)
			if tool in ("propose_patch", "scaffold_service"):
				view.add_item(self._ApproveJobButton(self, job_id))
				view.add_item(self._RejectJobButton(self, job_id))
			view.add_item(self._DetailsJobButton(self, job_id))
			await channel.send(embed=embed, view=view)
		except Exception as e:
			await channel.send(f"[builder-notify error] {e}")


async def start_discord_bot(coordinator: AgentCoordinator, token: str):
    bot = DiscordAgentBot(coordinator)
    try:
        await bot.start(token)
    except Exception as e:
        print(f"[DiscordBot] Error: {e}")


if __name__ == "__main__":
    from agent_coordinator import create_agent_coordinator

    async def main():
        coordinator = await create_agent_coordinator()
        token = os.getenv("DISCORD_BOT_TOKEN")
        if not token:
            print("Error: DISCORD_BOT_TOKEN environment variable not set")
            return
        await start_discord_bot(coordinator, token)

    asyncio.run(main())
